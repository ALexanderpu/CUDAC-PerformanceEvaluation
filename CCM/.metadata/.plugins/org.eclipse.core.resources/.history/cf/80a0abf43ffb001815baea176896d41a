#include <bits/stdc++.h>
using namespace std;
class ConfigReader
{
	private:
		// section, name, value
		std::unordered_map<string, unordered_map<string, string>> records;

		// check only if ' '; '\t'; '\n'; '\f'; '\r' exist
		// usually it is to split words in the sentence
		bool space_only(const string& line){
			for(size_t i = 0; i < line.length();i++){
				if(std::isspace((unsigned char)line[i]))
					return false;
			}
			return true;
		}
		// erase the leading space and trailing space
		std::string& trim(std::string& s){
		    auto is_whitespace = [] (char c) -> bool { return c == ' ' || c == '\t'; };
			auto first_non_whitespace = std::find_if_not(s.begin(), s.end(), is_whitespace);
			s.erase(begin(s), first_non_whitespace);
			auto last_non_whitespace = std::find_if_not(s.rbegin(), s.rend(), is_whitespace).base();
			s.erase(next(last_non_whitespace), end(s));
			return s;
		}
		// erase the middle space
		std::string& normalize(std::string& s) {
		    s.erase(std::remove_if(begin(s), end(s),[] (char c) { return c == ' ' || c == '\t'; }), end(s));
		    return s;
		}

		bool is_valid (std::string & line){
			trim(line);
		    normalize (line);
		    std::size_t i = 0;
		    // if the line is a section
		    if (line[i] == '[')
		    {
		        // find where the section's name ends
		        std::size_t j = line.find_last_of (']');
		        // if the ']' character wasn't found, then the line is invalid.
		        if (j == std::string::npos)
		            return false;
		        // if the distance between '[' and ']' is equal to one,
		        // then there are no characters between section brackets -> invalid line.
		        if (j - i == 1)
		            return false;
		    }
		    /* Check if a line is a comment */
		    else if (line[i] == ';' || line[i] == '#' || (line[i] == '/' && line[i + 1] == '/'))
		        return false;
		    /* Check if a line is ill-formed */
		    else if (line[i] == '=' || line[i] == ']')
		        return false;
		    else // is key=value pattern?
		    {
		        std::size_t j = line.find_last_of ('=');
		        if (j == std::string::npos)
		            return false;
		        if (j + 1 >= line.length())
		            return false;
		    }
		    return true;
		}
		void parse(std::string& section, std::string& line){
			std::size_t i = 0;
			if(line[i] == '['){
				i++;
				std::size_t j = line.find_last_of(']')-1;
				section = line.substr(i, j);
			}else{
				std::string sec(section);
				std::size_t j = line.find ('=');
				std::string name = line.substr (i, j);
				std::string value = line.substr(j+1);
				records[sec][name] = value;
			}
		}
	public:

        ConfigReader(){};

        explicit ConfigReader (const std::string & file){
        	read_file (file);
        }

        bool read_file (const std::string& file);

        std::string get_string (const std::string & tsection, const std::string & tname);

};

bool ConfigReader::read_file(const std::string& file){
	records.clear();
	std::ifstream config(file);
	if(!config.is_open())
		return false;
	std::string section;
	std::string buffer;

	while(std::getline(config, buffer, '\n')){
		if(is_valid(buffer)){
			parse(section, buffer);
		}else{
			return false;
		}
	}
	return true;
}

std::string ConfigReader::get_string (const std::string & tsection, const std::string & tname){
	return records[tsection][tname];
}

struct IncGenerator {
    int current_, interval_;
    IncGenerator (int start, int interval) : current_(start),interval_(interval) {}
    int operator() () { return current_ += interval_; }
};

int main(int argc, char **argv){
	string file = "/home/bo/cloud/CCM-Parralization/ccm.cfg";
	ConfigReader cr;
	cr.read_file(file);

	string input = cr.get_string("paths", "input");
	string output = cr.get_string("paths", "output");

	string E = cr.get_string("parameters", "E");
	string tau = cr.get_string("parameters", "tau");

	// parse to int vector
	std::vector<int> EArr, tauArr;
	std::stringstream Ess(E), tauss(tau);
	int i;
	while(Ess >> i){
		EArr.push_back(i);
		if(Ess.peek() == ',')
			Ess.ignore();
	}
	while(tauss >> i){
		tauArr.push_back(i);
		if(tauss.peek() == ',')
			tauss.ignore();
	}

	int num_samples = stoi(cr.get_string("parameters", "num_samples"));

	int LStart = stoi(cr.get_string("parameters", "LStart"));
	int LEnd = stoi(cr.get_string("parameters", "LEnd"));
	int LInterval = stoi(cr.get_string("parameters", "LInterval"));

	size_t Lsize = (LEnd-LStart)/LInterval + 1;
	std::vector<int> LArr(Lsize);
	IncGenerator g (LStart, LInterval);
	std::generate(LArr.begin(), LArr.end(), g);
	cout << "LArr: " << endl;
	for(auto ele: LArr){
		cout << ele << endl;
	}
	cout << "EArr: " << endl;
	for(auto ele: EArr){
		cout << ele << endl;
	}
	cout << "tauArr: " << endl;
	for(auto ele: tauArr){
		cout << ele << endl;
	}

	return 0;

}
