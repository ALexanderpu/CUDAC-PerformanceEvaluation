# because there can be an extra small number in the transition between from the short step size to the longer one, to get the smallest
# standard step size, get the SECOND smallest one
smallestStandardStepL <- diff(uniqueLibrarySizes)[2]
countDistinctLibrarySizes <- maxLibrarySize/smallestStandardStepL
countRhoBins <- 100
gPlot <- createGGPlotInternal(ccmXY, isDisplayMAE, isTruncatePerRealizationRho)
png(strFileName)
result <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours) + ggtitle(strTitle)
print(result)
dev.off()
}
SuicideModel <- function(csv_df, window_size, Edimension){
delay <- min(window_size, Edimension-1)
x = head(rowSums(embed(csv_df$Suicide.Attempt.Count, window_size)), -(delay+1))
y = tail(csv_df$Suicide.Attempt.Count, -(window_size+delay))
df <- data.frame(x, y)
names(df) <- c("AccumulateCount","Count")
return(df)
}
CCMModel <- function(TimeSeries, strScenario, E, window_size, saveFigureDir, saveFolderName){
print(paste("start to run ccm for scenario", strScenario, "with combination E:", E, "window_size:", window_size))
maxL <- nrow(TimeSeries["AccumulateCount"])
stepL <- 50
vecLibrarySizes <- seq(50, maxL, stepL)
ccmXY <- ccm(TimeSeries, E=E, tau=1, lib_column="AccumulateCount", target_column="Count", lib_sizes=vecLibrarySizes, num_samples=samples)
ccmXY$nonnegRho = pmax(0, ccmXY$rho)
# collect the mean value for the longest value
LongestL = max(ccmXY$lib_size)
print(paste("The longest L is:", LongestL))
mean_rho = colMeans(subset(ccmXY, ccmXY$lib_size == LongestL, select=c("nonnegRho")))
print(paste("mean value with combination E:", E, "window_size:", window_size, "is:", mean_rho))
#create ccm plot
print("start to plot ccm")
SaveFileName = paste(saveFigureDir, saveFolderName, strScenario, "_E_", E, "_K_", window_size, ".png", sep="")
print(SaveFileName)
createPerRealizationDensityPlot(ccmXY, window_size, SaveFileName, isTruncatePerRealizationRho=TRUE)
print("finish the plot")
return(mean_rho)
}
# create df for different E
df <- data.frame(window_size_candidates)
for(E in E_candidates){
ccmVector <- c()  # plot meanRho-windowSize figure
for(window_size in window_size_candidates){
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, strScenarioTitle, E, window_size, home_dir, subfolder_name)
ccmVector <-c(ccmVector, meanRho)
}
df[[paste(strScenarioTitle, "_E_", E, sep = "")]] <- ccmVector
}
ScenarioNum = 17
strScenarioTitle = paste("Scenario_", ScenarioNum, sep="")
CsvFile = paste(home_dir, ScenarioNum, ".csv", sep="")
print(paste("read csv file:", CsvFile))
SuicideCounts = read.csv(CsvFile)
E_candidates <- c(2)
window_size_candidates <- c(1)
# create df for different E
df <- data.frame(window_size_candidates)
for(E in E_candidates){
ccmVector <- c()  # plot meanRho-windowSize figure
for(window_size in window_size_candidates){
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, strScenarioTitle, E, window_size, home_dir, subfolder_name)
ccmVector <-c(ccmVector, meanRho)
}
df[[paste(strScenarioTitle, "_E_", E, sep = "")]] <- ccmVector
}
#save df
write.csv(df, file=paste(home_dir, subfolder_name , strScenarioTitle, "_meanRho.csv", sep = ""), row.names=TRUE)
# plot figure
strMeanFileName = paste(home_dir,subfolder_name, strScenarioTitle, "_meanRho.png", sep = "")
df$X<-NULL
melted = melt(df, id.vars="window_size_candidates")
png(strMeanFileName)
figure <- ggplot() + geom_line(data=melted, aes(x=window_size_candidates, y=value, group=variable, colour=variable)) + geom_line(size=2) + ggtitle("Suicide Model") + xlab("Window Size") + ylab("Mean Rho")
print(figure)
dev.off()
library('reshape2')
ScenarioNum = "output"
strScenarioTitle = paste("Scenario_", ScenarioNum, sep="")
CsvFile = paste(home_dir, ScenarioNum, ".csv", sep="")
print(paste("read csv file:", CsvFile))
SuicideCounts = read.csv(CsvFile)
E_candidates <- c(3)
window_size_candidates <- c(3)
# create df for different E
df <- data.frame(window_size_candidates)
for(E in E_candidates){
ccmVector <- c()  # plot meanRho-windowSize figure
for(window_size in window_size_candidates){
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, strScenarioTitle, E, window_size, home_dir, subfolder_name)
ccmVector <-c(ccmVector, meanRho)
}
df[[paste(strScenarioTitle, "_E_", E, sep = "")]] <- ccmVector
}
#save df
write.csv(df, file=paste(home_dir, subfolder_name , strScenarioTitle, "_meanRho.csv", sep = ""), row.names=TRUE)
# plot figure
strMeanFileName = paste(home_dir,subfolder_name, strScenarioTitle, "_meanRho.png", sep = "")
df$X<-NULL
melted = melt(df, id.vars="window_size_candidates")
png(strMeanFileName)
figure <- ggplot() + geom_line(data=melted, aes(x=window_size_candidates, y=value, group=variable, colour=variable)) + geom_line(size=2) + ggtitle("Suicide Model") + xlab("Window Size") + ylab("Mean Rho")
print(figure)
dev.off()
E = 3
window_size = 4
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
TimeSeries
SuicideCounts
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
TimeSeries
SuicideModel <- function(csv_df, window_size, Edimension){
# delay <- min(window_size, Edimension-1)
x = head(rowSums(embed(csv_df$Suicide.Attempt.Count, window_size)), -1)
y = tail(csv_df$Suicide.Attempt.Count, window_size)
df <- data.frame(x, y)
names(df) <- c("AccumulateCount","Count")
return(df)
}
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
SuicideModel <- function(csv_df, window_size, Edimension){
# delay <- min(window_size, Edimension-1)
x = head(rowSums(embed(csv_df$Suicide.Attempt.Count, window_size)), -1)
y = tail(csv_df$Suicide.Attempt.Count, -window_size)
df <- data.frame(x, y)
names(df) <- c("AccumulateCount","Count")
return(df)
}
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
TimeSeries
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, strScenarioTitle, E, window_size, home_dir, subfolder_name)
ccmVector <-c(ccmVector, meanRho)
SuicideCounts = read.csv(CsvFile)
SuicideCounts
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, strScenarioTitle, E, window_size, home_dir, subfolder_name)
SuicideModel <- function(csv_df, window_size, Edimension){
# delay <- min(window_size, Edimension-1)
#x = head(rowSums(embed(csv_df$Suicide.Attempt.Count, window_size)), -1)
#y = tail(csv_df$Suicide.Attempt.Count, -window_size)
delay <- min(window_size, Edimension-1)
x = head(rowSums(embed(csv_df$Suicide.Attempt.Count, window_size)), -(delay+1))
y = tail(csv_df$Suicide.Attempt.Count, -(window_size+delay))
df <- data.frame(x, y)
names(df) <- c("AccumulateCount","Count")
return(df)
}
#"AccumulateCount"
# "Count"
CCMModel <- function(TimeSeries, lib, target, strScenario, E, window_size, saveFigureDir, saveFolderName){
print(paste("start to run ccm for scenario", strScenario, "with combination E:", E, "window_size:", window_size))
maxL <- nrow(TimeSeries[target])
stepL <- 50
vecLibrarySizes <- seq(50, maxL, stepL)
ccmXY <- ccm(TimeSeries, E=E, tau=1, lib_column=lib, target_column=target, lib_sizes=vecLibrarySizes, num_samples=samples)
ccmXY$nonnegRho = pmax(0, ccmXY$rho)
# collect the mean value for the longest value
LongestL = max(ccmXY$lib_size)
print(paste("The longest L is:", LongestL))
mean_rho = colMeans(subset(ccmXY, ccmXY$lib_size == LongestL, select=c("nonnegRho")))
print(paste("mean value with combination E:", E, "window_size:", window_size, "is:", mean_rho))
#create ccm plot
print("start to plot ccm")
SaveFileName = paste(saveFigureDir, saveFolderName, strScenario, "_E_", E, "_K_", window_size, ".png", sep="")
print(SaveFileName)
createPerRealizationDensityPlot(ccmXY, window_size, SaveFileName, isTruncatePerRealizationRho=TRUE)
print("finish the plot")
return(mean_rho)
}
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, "Count", "AccumulateCount", strScenarioTitle, E, window_size, home_dir, subfolder_name)
ScenarioNum = 17
strScenarioTitle = paste("Scenario_", ScenarioNum, sep="")
CsvFile = paste(home_dir, ScenarioNum, ".csv", sep="")
print(paste("read csv file:", CsvFile))
SuicideCounts = read.csv(CsvFile)
E_candidates <- c(3)
window_size_candidates <- c(4)
# create df for different E
df <- data.frame(window_size_candidates)
for(E in E_candidates){
ccmVector <- c()  # plot meanRho-windowSize figure
for(window_size in window_size_candidates){
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, "Count", "AccumulateCount", strScenarioTitle, E, window_size, home_dir, subfolder_name)
ccmVector <-c(ccmVector, meanRho)
}
df[[paste(strScenarioTitle, "_E_", E, sep = "")]] <- ccmVector
}
CCMModel <- function(TimeSeries, lib, target, strScenario, E, window_size, saveFigureDir, saveFolderName){
print(paste("start to run ccm for scenario", strScenario, "with combination E:", E, "window_size:", window_size))
maxL <- nrow(TimeSeries[target])
stepL <- 100
vecLibrarySizes <- seq(50, maxL, stepL)
ccmXY <- ccm(TimeSeries, E=E, tau=1, lib_column=lib, target_column=target, lib_sizes=vecLibrarySizes, num_samples=samples)
ccmXY$nonnegRho = pmax(0, ccmXY$rho)
# collect the mean value for the longest value
LongestL = max(ccmXY$lib_size)
print(paste("The longest L is:", LongestL))
mean_rho = colMeans(subset(ccmXY, ccmXY$lib_size == LongestL, select=c("nonnegRho")))
print(paste("mean value with combination E:", E, "window_size:", window_size, "is:", mean_rho))
#create ccm plot
print("start to plot ccm")
SaveFileName = paste(saveFigureDir, saveFolderName, strScenario, "_E_", E, "_K_", window_size, ".png", sep="")
print(SaveFileName)
createPerRealizationDensityPlot(ccmXY, window_size, SaveFileName, isTruncatePerRealizationRho=TRUE)
print("finish the plot")
return(mean_rho)
}
ScenarioNum = 16
strScenarioTitle = paste("Scenario_", ScenarioNum, sep="")
CsvFile = paste(home_dir, ScenarioNum, ".csv", sep="")
print(paste("read csv file:", CsvFile))
SuicideCounts = read.csv(CsvFile)
E_candidates <- c(3)
window_size_candidates <- c(4)
# create df for different E
df <- data.frame(window_size_candidates)
for(E in E_candidates){
ccmVector <- c()  # plot meanRho-windowSize figure
for(window_size in window_size_candidates){
TimeSeries = SuicideModel(SuicideCounts, window_size, E)
meanRho = CCMModel(TimeSeries, "Count", "AccumulateCount", strScenarioTitle, E, window_size, home_dir, subfolder_name)
ccmVector <-c(ccmVector, meanRho)
}
df[[paste(strScenarioTitle, "_E_", E, sep = "")]] <- ccmVector
}
SuicideCounts
alpha = -window_size
alpha
as.vector(SuicideCounts[-c(1:window_size), ])
originalDataAllignedWithWindowedDataSize <- as.vector(SuicideCounts[-c(1:window_size), ])
TS <- zoo(SuicideCounts)
library(zoo)
install.packages(zoo)
install.packages("zoo")
library("zoo")
TS <- zoo(SuicideCounts)
TS
By = 2
windowedColumn <- as.vector(rollapply(TS, width = list(-1:alpha), by = By, FUN = sum, align = "right"))
windowedColumn
windowedDF = data.frame(suicideAttemptCount=originalDataAllignedWithWindowedDataSize, windowedSuicideAttemptCount=windowedColumn)
WS = 3
load("/Users/alexpb/Downloads/two_species_model.rda")
two_species_model
write.csv(two_species_model, file="/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/CCM/cmake-build-debug/test.csv")
two_species_model$time <- NULL
two_species_model
write.csv(two_species_model, file="/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/CCM/cmake-build-debug/test.csv")
library(rEDM)
two_species_model["x"]
maxL <- 799
stepL <- 100
vecLibrarySizes <- seq(100, maxL, stepL)
vecLibrarySizes
library(rEDM)
library("ggplot2")
library("hexbin")
library("RColorBrewer")
library(rEDM)
library("ggplot2")
library("hexbin")
library("RColorBrewer")
#library("rgl")
library("MASS")
samples = 250
createGGPlotInternal <- function(ccmXYIncludingNonnegColumn, isDisplayMAE, isTruncatePerRealizationRho)
{
if (isDisplayMAE)
gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=mae))
else
{
if (isTruncatePerRealizationRho)
gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=nonnegRho))
else
gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=rho))
}
return(gPlot)
}
createPerRealizationDensityPlot <- function(ccmXY, strFileName, strXDescription=ccmXY$lib_column[1], strYDescription=ccmXY$target_column[1], isTruncatePerRealizationRho=FALSE, isDisplayMAE=FALSE)
{
EEmbeddingDimension = ccmXY$E[1]
countSamplesPerL = ccmXY$num_pred[1]
tau = ccmXY$tau[1]
vecColours <- colorRampPalette(rev(brewer.pal(10,'Spectral')))(50)
strTitle = paste(strXDescription, " xmap ", strYDescription, "(E", EEmbeddingDimension, ",", "tau", tau, "," , samples , " samples)")
uniqueLibrarySizes <- unique(ccmXY$lib_size)
maxLibrarySize <- max(uniqueLibrarySizes)
# because there can be an extra small number in the transition between from the short step size to the longer one, to get the smallest
# standard step size, get the SECOND smallest one
smallestStandardStepL <- diff(uniqueLibrarySizes)[2]
countDistinctLibrarySizes <- maxLibrarySize/smallestStandardStepL
countRhoBins <- 100
gPlot <- createGGPlotInternal(ccmXY, isDisplayMAE, isTruncatePerRealizationRho)
png(strFileName)
result <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours) + ggtitle(strTitle)
print(result)
dev.off()
}
# share variable
saveFigureDir = "/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/"
saveFolderName = "C++/"
E_candidates = c(2, 3)
# read c++ csv
result = read.csv("/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/CCM/cmake-build-debug/final_result.csv")
for(E in E_candidates){
df = result[result$Case == E & result$E == E, ]
uniqueVecLibSizes = df$L
LibSize = rep(uniqueVecLibSizes, each=samples)
LenVec = length(uniqueVecLibSizes)
Rho = c()
for(iter in 1:LenVec){
ccm_vector = as.numeric(unlist(strsplit(as.character(df$CCM)[iter], split = " "))) #factor to string and split then numeric
ccm_vector = pmax(0, ccm_vector)
Rho = c(Rho, ccm_vector)
}
# construct ccmXY dataframe
strTitle = paste("x xmap y", "(Case", E, ",", "E", E, ",", "samples", samples, ") tau=1")
print(strTitle)
ccmDataFrame <- data.frame(LibSize, Rho)
names(ccmDataFrame) <- c("lib_size", "nonnegRho")
vecColours <- colorRampPalette(rev(brewer.pal(10,'Spectral')))(50)
maxLibrarySize <- max(uniqueVecLibSizes)
smallestStandardStepL <- diff(uniqueVecLibSizes)[1]
countDistinctLibrarySizes <- maxLibrarySize/smallestStandardStepL
countRhoBins <- 100
strPngTitle = paste("Case", case, "E", E, "samples", samples, sep = "_")
strPngFileName = paste(saveFigureDir, saveFolderName, strPngTitle, ".png", sep="")
png(strPngFileName)
gPlot <- createGGPlotInternal(ccmDataFrame, FALSE, TRUE)
ccmFigure <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours) + ggtitle(strTitle);
print(ccmFigure)
dev.off()
}
library(rEDM)
library("ggplot2")
library("hexbin")
library("RColorBrewer")
#library("rgl")
library("MASS")
samples = 250
createGGPlotInternal <- function(ccmXYIncludingNonnegColumn, isDisplayMAE, isTruncatePerRealizationRho)
{
if (isDisplayMAE)
gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=mae))
else
{
if (isTruncatePerRealizationRho)
gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=nonnegRho))
else
gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=rho))
}
return(gPlot)
}
createPerRealizationDensityPlot <- function(ccmXY, strFileName, strXDescription=ccmXY$lib_column[1], strYDescription=ccmXY$target_column[1], isTruncatePerRealizationRho=FALSE, isDisplayMAE=FALSE)
{
EEmbeddingDimension = ccmXY$E[1]
countSamplesPerL = ccmXY$num_pred[1]
tau = ccmXY$tau[1]
vecColours <- colorRampPalette(rev(brewer.pal(10,'Spectral')))(50)
strTitle = paste(strXDescription, " xmap ", strYDescription, "(E", EEmbeddingDimension, ",", "tau", tau, "," , samples , " samples)")
uniqueLibrarySizes <- unique(ccmXY$lib_size)
maxLibrarySize <- max(uniqueLibrarySizes)
# because there can be an extra small number in the transition between from the short step size to the longer one, to get the smallest
# standard step size, get the SECOND smallest one
smallestStandardStepL <- diff(uniqueLibrarySizes)[2]
countDistinctLibrarySizes <- maxLibrarySize/smallestStandardStepL
countRhoBins <- 100
gPlot <- createGGPlotInternal(ccmXY, isDisplayMAE, isTruncatePerRealizationRho)
png(strFileName)
result <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours) + ggtitle(strTitle)
print(result)
dev.off()
}
# share variable
saveFigureDir = "/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/"
saveFolderName = "C++/"
E_candidates = c(2, 3)
# read c++ csv
result = read.csv("/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/CCM/cmake-build-debug/final_result.csv")
for(E in E_candidates){
df = result[result$Case == E & result$E == E, ]
uniqueVecLibSizes = df$L
LibSize = rep(uniqueVecLibSizes, each=samples)
LenVec = length(uniqueVecLibSizes)
Rho = c()
for(iter in 1:LenVec){
ccm_vector = as.numeric(unlist(strsplit(as.character(df$CCM)[iter], split = " "))) #factor to string and split then numeric
ccm_vector = pmax(0, ccm_vector)
Rho = c(Rho, ccm_vector)
}
# construct ccmXY dataframe
strTitle = paste("x xmap y", "(Case", E, ",", "E", E, ",", "samples", samples, ") tau=1")
print(strTitle)
ccmDataFrame <- data.frame(LibSize, Rho)
names(ccmDataFrame) <- c("lib_size", "nonnegRho")
vecColours <- colorRampPalette(rev(brewer.pal(10,'Spectral')))(50)
maxLibrarySize <- max(uniqueVecLibSizes)
smallestStandardStepL <- diff(uniqueVecLibSizes)[1]
countDistinctLibrarySizes <- maxLibrarySize/smallestStandardStepL
countRhoBins <- 100
strPngTitle = paste("E", E, "samples", samples, sep = "_")
strPngFileName = paste(saveFigureDir, saveFolderName, strPngTitle, ".png", sep="")
png(strPngFileName)
gPlot <- createGGPlotInternal(ccmDataFrame, FALSE, TRUE)
ccmFigure <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours) + ggtitle(strTitle);
print(ccmFigure)
dev.off()
}
TimeSeries = two_species_model
target = "y"
lib = "x"
strScenario = "Rcode"
maxL <- 799
stepL <- 100
vecLibrarySizes <- seq(100, maxL, stepL)
for(E in E_candidates){
ccmXY <- ccm(TimeSeries, E=E, tau=1, lib_column=lib, target_column=target, lib_sizes=vecLibrarySizes, num_samples=samples)
ccmXY$nonnegRho = pmax(0, ccmXY$rho)
SaveFileName = paste(saveFigureDir, saveFolderName, strScenario, "_E_", E, ".png", sep="")
createPerRealizationDensityPlot(ccmXY, SaveFileName, isTruncatePerRealizationRho=TRUE)
}
SuicideModel <- function(csv_df, window_size, Edimension){
delay <- Edimension-1
x = head(rowSums(embed(csv_df$Suicide.Attempt.Count, window_size)), -(delay+1))
y = tail(csv_df$Suicide.Attempt.Count, -(window_size+delay))
df <- data.frame(x, y)
names(df) <- c("AccumulateCount","Count")
return(df)
}
read.csv("/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/daily_realData.csv")
df = read.csv("/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/daily_realData.csv")
result = SuicideModel(df, 3, 3)
result
write.csv(result, file="/Users/alexpb/Desktop/Lab/ABMCCM/CCMWithSuicideModeling/C++/CCM/test2.csv")
getwd
getwd()
setwd("/Users/alexpb/Desktop/Lab/PySparkCUDAC/data/")
getwd()
list.files(".")
load(list.files(".")[1])
test = load(list.files(".")[1])
test
file = list.files(".")[1]
file
outputFile = paste(strsplit(file, split=".")[1], ".csv", sep = "")
outputFile
strsplit(file, split=".")[1]
strsplit(file, split=".")
file
strsplit(file, split=".", fixed=TRUE)
strsplit(file, split=".", fixed=TRUE)[1]
strsplit(file, split=".", fixed=TRUE)[1][1]
strsplit(file, split=".", fixed=TRUE)[[1]]
strsplit(file, split=".", fixed=TRUE)[[1]][]
strsplit(file, split=".", fixed=TRUE)
strsplit(file, split=".", fixed=TRUE)[1]
file.rsplit(".")
file
file.rsplit()
file
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[1], ".csv", sep = "")
outputFile
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[1][1], ".csv", sep = "")
outputFile
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[[1]][1], ".csv", sep = "")
outputFile
get(indata)
indata <- load(file)
get(indata)
for(file in list.files(".")){
print(file)
indata <- load(file)
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[[1]][1], ".csv", sep = "")
print(paste("output file:", outputFile))
write.csv(get(indata), file=outputFile)
}
print(file)
print(files[3])
print(paste("output file:", outputFile))
write.csv(get(indata), file=outputFile)
for(file in files){
print(file)
indata <- load(file)
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[[1]][1], ".csv", sep = "")
print(paste("output file:", outputFile))
write.csv(get(indata), file=outputFile)
}
for(file in files){
print(file)
indata <- load(file)
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[[1]][1], ".csv", sep = "")
print(paste("output file:", outputFile))
write.csv(get(indata), file=outputFile)
}
files <- list.files(".")
for(file in files){
print(file)
indata <- load(file)
outputFile = paste(strsplit(file, split=".",fixed=TRUE)[[1]][1], ".csv", sep = "")
print(paste("output file:", outputFile))
write.csv(get(indata), file=outputFile)
}
getwd()
setwd("/Users/alexpb/Desktop/Lab/PySparkCUDAC/")
files <- list.files("./data/")
files
